import{IrisUtils}from"../../src/IrisUtils.js";class Model{constructor(e,r,t={}){this.name=e,this.schema=r,this.version=t.version||1,this.primary=t.primary||"_id",this.schema.definition[this.primary]?this.schema.definition[this.primary].type!==String?this.schema.definition[this.primary].type=String:this.schema.definition[this.primary]?.unique||(this.schema.definition[this.primary].unique=!0):this.schema.definition[this.primary]={type:String,unique:!0},this.db=null}async connect(){return new Promise(((e,r)=>{const t=indexedDB.open(this.name,this.version);t.onerror=()=>r(t.error),t.onsuccess=()=>{this.db=t.result,e(this.db)},t.onupgradeneeded=e=>{const r=e.target.result;if(!r.objectStoreNames.contains(this.name)){const e=r.createObjectStore(this.name,{keyPath:this.primary});this.schema.indexes.forEach((r=>{e.createIndex(r.field,r.field,{unique:r.unique||!1})}))}}}))}async disconnect(){this.db&&(this.db.close(),this.db=null)}async create(e,r={}){return r.castToScheme&&(e=this._prepare(e)),await this._validateData(e),this._executeTransaction("readwrite",(t=>new Promise(((n,s)=>{const i=t.add(r?.castToScheme?e:this._prepare(e));i.onsuccess=()=>n(e),i.onerror=()=>s(i.error)}))))}async findById(e){return this._executeTransaction("readonly",(r=>new Promise(((t,n)=>{const s=r.get(e);s.onsuccess=()=>t(s.result),s.onerror=()=>n(s.error)}))))}async find(e={}){return this._executeTransaction("readonly",(r=>new Promise(((t,n)=>{const s=[],i=r.openCursor();i.onsuccess=r=>{const n=r.target.result;n?(this._matchesQuery(n.value,e)&&s.push(n.value),n.continue()):t(s)},i.onerror=()=>n(i.error)}))))}async sort({fields:e,keyField:r,order:t="asc"}){return e.sort(((e,n)=>"asc"===t?"date"===r?.type?new Date(e[r.name])-new Date(n[r.name]):e[r.name]-n[r.name]:"date"===r?.type?new Date(n[r.name])-new Date(e[r.name]):n[r.name]-e[r.name])),e}async limit({fields:e,limit:r}){return e.slice(0,r)}async update(e,r){return await this._validateData(r,"update"),this._executeTransaction("readwrite",(t=>new Promise(((n,s)=>{const i=t.get(e);i.onsuccess=()=>{const e=i.result;if(!e)return void s(new Error("Item not found"));const a={...e,...this._prepare(r)},o=t.put(a);o.onsuccess=()=>n(a),o.onerror=()=>s(o.error)},i.onerror=()=>s(i.error)}))))}async delete(e){return this._executeTransaction("readwrite",(r=>new Promise(((t,n)=>{const s=r.delete(e);s.onsuccess=()=>t(!0),s.onerror=()=>n(s.error)}))))}async deleteMany(e){const r=await this.find(e);return Promise.all(r.map((e=>this.delete(e[this.primary]))))}async checkIndex(e){return new Promise(((r,t)=>{const n=indexedDB.open(this.name,this.version);n.onsuccess=()=>{const t=n.result.transaction(this.name,"readonly").objectStore(this.name).indexNames.contains(e);r(t)},n.onerror=()=>t(n.error)}))}async createIndex(e){return new Promise(((r,t)=>{const n=indexedDB.open(this.name,this.version);n.onsuccess=()=>{n.result.transaction(this.name,"readwrite").objectStore(this.name).createIndex(e,e),r(!0)},n.onerror=()=>t(n.error)}))}async dropIndex(e){return new Promise(((r,t)=>{const n=indexedDB.open(this.name,this.version);n.onsuccess=()=>{n.result.transaction(this.name,"readwrite").objectStore(this.name).deleteIndex(e),r(!0)},n.onerror=()=>t(n.error)}))}async getPrimaryKeyStore(){return new Promise(((e,r)=>{const t=indexedDB.open(this.name,this.version);t.onsuccess=()=>{const r=t.result.transaction(this.name,"readonly").objectStore(this.name);e(r.keyPath)},t.onerror=()=>r(t.error)}))}async getStore(){return new Promise(((e,r)=>{const t=indexedDB.open(this.name,this.version);t.onsuccess=()=>{const r=t.result.transaction(this.name,"readonly").objectStore(this.name);e(r)},t.onerror=()=>r(t.error)}))}async clear(){return this._executeTransaction("readwrite",(e=>new Promise(((r,t)=>{const n=e.clear();n.onsuccess=()=>r(!0),n.onerror=()=>t(n.error)}))))}async count(){return this._executeTransaction("readonly",(e=>new Promise(((r,t)=>{const n=e.count();n.onsuccess=()=>r(n.result),n.onerror=()=>t(n.error)}))))}async drop(){return new Promise(((e,r)=>{const t=indexedDB.deleteDatabase(this.name);t.onsuccess=()=>e(!0),t.onerror=()=>r(t.error)}))}async validatePrimaryKey(e){return e[this.primary]&&void 0!==e[this.primary]?24!==e[this.primary].length?"w":"s":"e"}async _validateData(e,r="create"){if("create"===r&&"e"===await this.validatePrimaryKey(e))e[this.primary]=await IrisUtils.generateObjectId();else if("update"===r&&"e"===await this.validatePrimaryKey(e))throw new Error(`Primary key '${this.primary}' is required for update operation`);const t=[];for(const[n,s]of Object.entries(this.schema.definition)){if(s.required&&!e.hasOwnProperty(n)&&t.push(`Field '${n}' is required`),s.unique&&"update"!==r){(await this.find({[n]:e[n]})).length>0&&t.push(`Field '${n}' must be unique`)}if(e.hasOwnProperty(n)&&null!==e[n]){const r=e[n],i=s.type||s;this._isValidType(r,i)||t.push(`Field '${n}' must be of type ${i.name}`)}if(s.validate&&e.hasOwnProperty(n))try{await s.validate(e[n])||t.push(`Validation failed for field '${n}'`)}catch(e){t.push(`Validation error for field '${n}': ${e.message}`)}}if(t.length>0)throw new Error(`Validation failed: ${t.join(", ")} - ${JSON.stringify(e)}`)}async _executeTransaction(e,r){return this.db||await this.connect(),new Promise(((t,n)=>{const s=this.db.transaction(this.name,e),i=s.objectStore(this.name);s.oncomplete=()=>t(),s.onerror=()=>n(s.error),Promise.resolve(r(i)).then(t).catch(n)}))}_prepare(e){const r={};for(const[t,n]of Object.entries(e))this.schema.definition[t]&&(r[t]=this._castValue(n,this.schema.definition[t]?.type));return r}_castValue(e,r){try{switch(r){case String:return String(e);case Number:return Number(e);case Boolean:return Boolean(e);case Date:{const r=e instanceof Date?e:"string"!=typeof e||isNaN(Date.parse(e))?null:new Date(e);return!r||isNaN(r.getTime())?null:r}default:return e}}catch(e){return null}}_isValidType(e,r){return r===String?"string"==typeof e:r===Number?"number"==typeof e&&!isNaN(e):r===Boolean?"boolean"==typeof e:r===Date?e instanceof Date&&!isNaN(e):r===Array?Array.isArray(e):r===Object?"object"==typeof e&&null!==e:e instanceof r}_matchesQuery(e,r){return Object.entries(r).every((([r,t])=>t&&"object"==typeof t?Object.entries(t).every((([t,n])=>{switch(t){case"$gt":return e[r]>n;case"$gte":return e[r]>=n;case"$lt":return e[r]<n;case"$lte":return e[r]<=n;case"$ne":return e[r]!==n;case"$in":return n.includes(e[r]);case"$nin":return!n.includes(e[r]);default:return!1}})):e[r]===t))}}export{Model};