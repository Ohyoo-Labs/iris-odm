import{IrisUtils}from"./IrisUtils.js";class Model{constructor(e,t,r={}){this.name=e,this.schema=t,this.version=r.version||1,this.primary=r.primary||"_id",this.collections=Array.isArray(r?.collections)&&r?.collections.length>0?r.collections:[],this.schema.definition[`${this.primary}`]?this.schema.definition[this.primary].type!==String?(console.warn(`We convert the ${this.primary} key to a string for better compatibility with non-relational databases`),this.schema.definition[this.primary].type=String):this.schema.definition[this.primary]?.unique||(this.schema.definition[this.primary].unique=!0):this.schema.definition[this.primary]={type:String,unique:!0},this.activeCollection=r?.active||this.name,this.db=null}async connect(){return new Promise((async(e,t)=>{this.version=await this.syncVersion(this.version);const r=indexedDB.open(this.name,this.version);r.onerror=()=>t(r.error),r.onsuccess=async()=>{this.db=r.result,this.collections=Array.from(this.db.objectStoreNames),e(this.db)},r.onupgradeneeded=e=>{const t=e.target.result;if(this.collections.length>0)this.collections.forEach((e=>{if(!t.objectStoreNames.contains(e)){const r=t.createObjectStore(e,{keyPath:this.primary});this.schema.indexes.forEach((e=>{r.createIndex(e.field,e.field,{unique:e.unique||!1})}))}}));else if(!t.objectStoreNames.contains(this.name)){const e=t.createObjectStore(this.name,{keyPath:this.primary});this.schema.indexes.forEach((t=>{e.createIndex(t.field,t.field,{unique:t.unique||!1})}))}}}))}async disconnect(){this.db&&(this.db.close(),this.db=null)}async syncVersion(e){return this.dbExists(this.name).then((t=>t?e&&e<t.version?this.version=t.version:this.version=e:this.version=1)).catch((e=>(console.error(e),this.version=1)))}async dbExists(e){return indexedDB.databases().then((t=>t.find((t=>t.name===e))))}static async existsDB(e){return indexedDB.databases().then((t=>t.find((t=>t.name===e))))}async addCollections(e){return this.db||await this.connect(),new Promise(((t,r)=>{const s=Array.from(this.db.objectStoreNames);"string"==typeof e&&(e=[e]);const n=e.filter((e=>!s.includes(e)));if(0===n.length)return t({success:!1,message:"Todas las colecciones ya existen en la base de datos.",addedCollections:[],allCollections:s});const i=this.db.name;this.version++,this.db.close();const o=indexedDB.open(i,this.version);o.onerror=()=>r(o.error),o.onsuccess=()=>{this.db=o.result,t({success:!0,addedCollections:n,allCollections:Array.from(this.db.objectStoreNames)})},o.onupgradeneeded=e=>{const t=e.target.result;n.forEach((e=>{const r=t.createObjectStore(e,{keyPath:this.primary});this.schema.indexes.forEach((e=>{r.createIndex(e.field,e.field,{unique:e.unique||!1})}))}))},this.collections=[...s,...n]}))}async switchCollection(e){try{if(!this.collections.includes(e))throw new Error(`Collection '${e}' not found`);return this.activeCollection=e,this.activeCollection}catch(e){return console.error(e),null}}async refresh(){return await this.disconnect(),await this.connect()}async create(e,t={}){return t.castToScheme&&(e=this._prepare(e)),await this._validateData(e),this._executeTransaction("readwrite",(r=>new Promise(((s,n)=>{const i=r.add(t?.castToScheme?e:this._prepare(e));i.onsuccess=()=>s(e),i.onerror=()=>n(i.error)}))))}async findById(e,t=null){return this._executeTransaction("readonly",(r=>new Promise(((s,n)=>{const i=r.get(e);i.onsuccess=()=>{if(i.result&&t){const e={};for(let r=0;r<t.length;r++){const s=t[r];i.result.hasOwnProperty(s)&&(e[s]=i.result[s])}s(e)}else s(i.result)},i.onerror=()=>n(i.error)}))))}async find({query:e=null,fields:t=null}={}){return this._executeTransaction("readonly",(r=>new Promise(((s,n)=>{const i=[],o=r.openCursor();o.onsuccess=r=>{const n=r.target.result;if(n){let r=n.value;if(t){const e={};for(let r=0;r<t.length;r++){const s=t[r];n.value.hasOwnProperty(s)&&(e[s]=n.value[s])}r=e}e?this._matchesQuery(n.value,e)&&i.push(r):i.push(r),n.continue()}else s(i)},o.onerror=()=>n(o.error)}))))}async sort({fields:e,keyField:t,order:r="asc"}){return e.sort(((e,s)=>"asc"===r?"date"===t?.type?new Date(e[t.name])-new Date(s[t.name]):e[t.name]-s[t.name]:"date"===t?.type?new Date(s[t.name])-new Date(e[t.name]):s[t.name]-e[t.name])),e}async limit({fields:e,limit:t}){return e.slice(0,t)}async update(e,t){return t=t||e[this.primary],delete e[this.primary],await this._validateData(e,"update",t),this._executeTransaction("readwrite",(r=>new Promise(((s,n)=>{const i=r.get(t);i.onsuccess=()=>{const t=i.result;if(!t)return void n(new Error("Item not found"));const o={...t,...this._prepare(e)},a=r.put(o);a.onsuccess=()=>s(o),a.onerror=()=>n(a.error)},i.onerror=()=>n(i.error)}))))}async delete(e){return this._executeTransaction("readwrite",(t=>new Promise(((r,s)=>{const n=t.delete(e);n.onsuccess=()=>r(e),n.onerror=()=>s(n.error)}))))}async deleteMany(e){const t=await this.find(e);return Promise.all(t.map((e=>this.delete(e[this.primary]))))}async checkIndex(e){return new Promise(((t,r)=>{const s=indexedDB.open(this.name,this.version);s.onsuccess=()=>{const r=s.result.transaction(this.name,"readonly").objectStore(this.name).indexNames.contains(e);t(r)},s.onerror=()=>r(s.error)}))}async createIndex(e){return new Promise(((t,r)=>{const s=indexedDB.open(this.name,this.version);s.onsuccess=()=>{s.result.transaction(this.name,"readwrite").objectStore(this.name).createIndex(e,e),t(!0)},s.onerror=()=>r(s.error)}))}async dropIndex(e){return new Promise(((t,r)=>{const s=indexedDB.open(this.name,this.version);s.onsuccess=()=>{s.result.transaction(this.name,"readwrite").objectStore(this.name).deleteIndex(e),t(!0)},s.onerror=()=>r(s.error)}))}async getPrimaryKeyStore(){return new Promise(((e,t)=>{const r=indexedDB.open(this.name,this.version);r.onsuccess=()=>{const t=r.result.transaction(this.name,"readonly").objectStore(this.name);e(t.keyPath)},r.onerror=()=>t(r.error)}))}async getStore(){return new Promise(((e,t)=>{const r=indexedDB.open(this.name,this.version);r.onsuccess=()=>{const t=r.result.transaction(this.name,"readonly").objectStore(this.name);e(t)},r.onerror=()=>t(r.error)}))}async clear(){return this._executeTransaction("readwrite",(e=>new Promise(((t,r)=>{const s=e.clear();s.onsuccess=()=>t(!0),s.onerror=()=>r(s.error)}))))}async count(){return this._executeTransaction("readonly",(e=>new Promise(((t,r)=>{const s=e.count();s.onsuccess=()=>t(s.result),s.onerror=()=>r(s.error)}))))}async drop(){return new Promise(((e,t)=>{const r=indexedDB.deleteDatabase(this.name);r.onsuccess=()=>e(!0),r.onerror=()=>t(r.error)}))}async validatePrimaryKey(e){return e[this.primary]&&void 0!==e[this.primary]?24!==e[this.primary].length?(console.warn(`We recommend using a 24-character string as the ${this.primary} key for better security`),"w"):"s":"e"}async _validateData(e,t="create",r){if("create"===t&&"e"===await this.validatePrimaryKey(e))e[this.primary]=await IrisUtils.generateObjectId();else if("update"===t&&!r)throw new Error(`Primary key '${this.primary}' is required for update operation`);const s=[];for(const[r,n]of Object.entries(this.schema.definition)){if(n.required&&!e.hasOwnProperty(r)&&s.push(`Field '${r}' is required`),n.unique&&"update"!==t){(await this.find({[r]:e[r]})).length>0&&s.push(`Field '${r}' must be unique`)}if(e.hasOwnProperty(r)&&null!==e[r]){const t=e[r],i=n.type||n;this._isValidType(t,i)||s.push(`Field '${r}' must be of type ${i.name}`)}if(n.validate&&e.hasOwnProperty(r))try{await n.validate(e[r])||s.push(`Validation failed for field '${r}'`)}catch(e){s.push(`Validation error for field '${r}': ${e.message}`)}}if(s.length>0)throw new Error(`Validation failed: ${s.join(", ")} - ${JSON.stringify(e)}`)}async _executeTransaction(e,t){return this.db||await this.connect(),new Promise(((r,s)=>{const n=this.db.transaction(this.activeCollection,e),i=n.objectStore(this.activeCollection);n.oncomplete=()=>r(),n.onerror=()=>s(n.error),Promise.resolve(t(i)).then(r).catch(s)}))}_prepare(e){const t={};for(const[r,s]of Object.entries(e))this.schema.definition[r]&&(t[r]=this._castValue(s,this.schema.definition[r]?.type));return t}_castValue(e,t){try{switch(t){case String:return String(e);case Number:return Number(e);case Boolean:return Boolean(e);case Date:{const t=e instanceof Date?e:"string"!=typeof e||isNaN(Date.parse(e))?null:new Date(e);return!t||isNaN(t.getTime())?(console.warn(`Invalid date value: ${e}`),null):t}default:return e}}catch(e){return console.error(e),null}}_isValidType(e,t){return t===String?"string"==typeof e:t===Number?"number"==typeof e&&!isNaN(e):t===Boolean?"boolean"==typeof e:t===Date?e instanceof Date&&!isNaN(e):t===Array?Array.isArray(e):t===Object?"object"==typeof e&&null!==e:e instanceof t}_matchesQuery(e,t){return Object.entries(t).every((([t,r])=>r&&"object"==typeof r?Object.entries(r).every((([r,s])=>{switch(r){case"$gt":return e[t]>s;case"$gte":return e[t]>=s;case"$lt":return e[t]<s;case"$lte":return e[t]<=s;case"$ne":return e[t]!==s;case"$in":return s.includes(e[t]);case"$nin":return!s.includes(e[t]);default:return!1}})):e[t]===r))}async databases(){return indexedDB.databases().then((e=>e.map((e=>({name:e.name,version:e.version})))))}async analyzeDB(e){return new Promise(((t,r)=>{try{const s=indexedDB.open(e);s.onsuccess=e=>{const r=e.target.result,s={name:r.name,version:r.version,objectStores:[]},n=r.objectStoreNames;for(let e=0;e<n.length;e++){const t=n[e],i=r.transaction(t,"readonly").objectStore(t),o={name:t,indexes:[]},a=i.indexNames;for(let e=0;e<a.length;e++){const t=i.index(a[e]);o.indexes.push({name:t.name,keyPath:t.keyPath,unique:t.unique})}s.objectStores.push(o)}r.close(),t(s)},s.onerror=e=>{r(new Error(`No se pudo abrir la base de datos: ${e.target.error}`))}}catch(e){r(new Error(`Error al analizar la base de datos: ${e.message}`))}}))}}export{Model};